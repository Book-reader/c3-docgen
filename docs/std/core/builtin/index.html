<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"></head><body><h2 class="header"><span class="selected">Overview</span>&nbsp<a href="../../../std/core/builtin/globals.html">Globals</a>&nbsp<a href="../../../std/core/builtin/types.html">Types</a>&nbsp<a href="../../../std/core/builtin/functions.html">Functions</a>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">builtin</span></h1></div><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/builtin/globals.html#EMPTY_MACRO_SLOT">EMPTY_MACRO_SLOT</a></td><td>EMPTY_MACRO_SLOT is a value used for implementing optional arguments for macros in an efficientway. It relies on the fact that distinct types are not implicitly convertable.You can use `@is_empty_macro_slot()` and `@is_valid_macro_slot()` to figure out whetherthe argument has been used or not.An example:```c3macro foo(a, #b = EMPTY_MACRO_SLOT){	$if @is_valid_macro_slot(#b):		return invoke_foo2(a, #b);	$else		return invoke_foo1(a);	$endif}</td></tr><tr><td><a href="../../../std/core/builtin/globals.html#old_segmentation_fault">old_segmentation_fault</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/globals.html#panic">panic</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/globals.html#MAX_FRAMEADDRESS">MAX_FRAMEADDRESS</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/globals.html#old_bus_error">old_bus_error</a></td><td></td></tr></table><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/builtin/functions.html#@as_char_view">@as_char_view</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#swizzle2">swizzle2</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@scope">@scope</a></td><td>Stores a variable on the stack, then restores it at the end of themacro scope.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#less_eq">less_eq</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#bitcast">bitcast</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#equals">equals</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@prefetch">@prefetch</a></td><td>Prefetch a pointer.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#unreachable">unreachable</a></td><td>Marks the path as unreachable. This will panic in safe mode, and in fast will simply be assumednever happens.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#any_make">any_make</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@is_empty_macro_slot">@is_empty_macro_slot</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@str_hash">@str_hash</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#min">min</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#swizzle">swizzle</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#abort">abort</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@typekind">@typekind</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#enum_by_name">enum_by_name</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@bitsizeof">@bitsizeof</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#sig_segmentation_fault">builtin::sig_segmentation_fault</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#bitsizeof">bitsizeof</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@assignable_to">@assignable_to</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#greater_eq">greater_eq</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@is_valid_macro_slot">@is_valid_macro_slot</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#get_frameaddress">builtin::get_frameaddress</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#max">max</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#compare_to">compare_to</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#get_returnaddress">builtin::get_returnaddress</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@try">@try</a></td><td>Check if an Optional expression evaluates to a fault. If so, return it;else, assign the result to an expression.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@rnd">@rnd</a></td><td>Returns a random value at compile time.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@str_upper">@str_upper</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@try_catch">@try_catch</a></td><td>Check if an Optional expression evaluates to a fault. If so, return true if it is theexpected fault, the optional if it is unexpected, or false if there was no fault andthe assign happened.This can be used in like this: while (true) {	char[] data;	// Read until end of file	if (@try_catch(data, load_line(), io::EOF)) break;	.. use data .. }In this example we read until we reach an EOF, which is expected. However, if we encounter some otherfault, we rethrow is. Without this macro, the code is instead written like: while (true) {	char[]? data;	data = load_line();	if (catch err = data)	{	  if (err = io::EOF) break;	  return err?	}	.. use data .. }</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#sig_panic">builtin::sig_panic</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@catch">@catch</a></td><td>Return the excuse in the Optional if it is Empty, otherwisereturn a null fault.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@swap">@swap</a></td><td>Swap two variables</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#sig_bus_error">builtin::sig_bus_error</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#greater">greater</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@clz">@clz</a></td><td>Returns the count of leading zero bits from an integer at compile-time.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#breakpoint">breakpoint</a></td><td>Unconditionally break into an attached debugger when reached.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#print_backtrace">builtin::print_backtrace</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@enum_from_value">@enum_from_value</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@typeid">@typeid</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@expect">@expect</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@generic_hash">builtin::@generic_hash</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@str_find">@str_find</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@generic_hash_core">builtin::@generic_hash_core</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@str_lower">@str_lower</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#unsupported">unsupported</a></td><td>Marks the path as unsupported, this is similar to unreachable.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@addr">@addr</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@unlikely">@unlikely</a></td><td>Mark an expression as unlikely to be true</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#default_panic">builtin::default_panic</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@ok">@ok</a></td><td>Check if an Optional expression holds a value or is empty, returning trueif it has a value.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#anycast">anycast</a></td><td>Convert an `any` type to a type, returning an failure if there is a type mismatch.</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@typeis">@typeis</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#panicf">builtin::panicf</a></td><td></td></tr><tr><td><a href="../../../std/core/builtin/functions.html#@likely">@likely</a></td><td>Mark an expression as likely to be true</td></tr><tr><td><a href="../../../std/core/builtin/functions.html#less">less</a></td><td></td></tr></table></body></html>