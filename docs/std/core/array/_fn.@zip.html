<!DOCTYPE html><html><head><link rel="stylesheet" href="../../../style.css"><script src="../../../main.js"></script></head><body><div class="main"><div class="module_path"><h1><a href="../../../std/index.html" target="_parent">std</a>::<a href="../../../std/core/index.html" target="_parent">core</a>::<span style="font-family: 'monospace'">array</span></h1></div><h1>@zip</h1>Zip together two separate arrays/slices into a single array of Pairs or return values. Values will<br/>be collected up to the length of the shorter array if `fill_with` is left undefined; otherwise, they<br/>will be collected up to the length of the LONGER array, with missing values in the shorter array being<br/>assigned to the value of `fill_with`. Return array elements do not have to be of the same type.<br/><br/>For example:<br/>```c3<br/>uint[] chosen_session_ids = server::get_random_sessions(instance)[:128];<br/>String[200] refreshed_session_keys = prng::new_keys_batch();<br/><br/>Pair { uint, String }[] sessions_meta = array::zip(mem, chosen_session_ids, refreshed_session_keys);<br/>// The resulting Pair{}[] slice is then length of the shortest of the two arrays, so 128.<br/><br/>foreach (i, &amp;sess : sessions:meta) {<br/>    // distribute new session keys to associated instance IDs<br/>}<br/>```<br/><br/>Or:<br/>```c3<br/>String[] client_names = server::online_usernames(instance);<br/>uint128[] session_ids = server::user_keys();<br/><br/>// in this example, we &apos;know&apos; ahead of time that &apos;session_ids&apos; can only ever be SHORTER<br/>//   than &apos;client_names&apos;, but never longer, because it&apos;s possible new users have logged<br/>//   in without getting whatever this &apos;session ID&apos; is delegated to them.<br/>Pair { String, uint128 }[] zipped = array::tzip(client_names, session_ids, fill_with: uint128.max);<br/><br/>server::refresh_session_keys_by_pair(zipped)!;<br/>```<br/><br/>### When an `operation` is supplied...<br/>Apply an operation to each element of two slices or arrays and return the results of<br/>each operation into a newly allocated array.<br/><br/>This essentially combines Iterable1 with Iterable2 using the `operation` functor.<br/><br/>See the functional `zipWith` construct, which has a more appropriate name than, e.g., `map`;<br/>  a la: https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:zipWith<br/><br/>Similar to &quot;normal&quot; `zip`, this macro pads the shorter input array with a given `fill_with`, or<br/>an empty value if one isn&apos;t supplied. This `fill_with` is supplied to the `operation` functor<br/>_BEFORE_ calculating its result while zipping.<br/><br/>For example: a functor of `fn char (char a, char b) =&gt; a + b` with a `fill_with` of 7,<br/>where the `left` array is the shorter iterable, will put 7 into that lambda in each place<br/>where `left` is being filled in during the zip operation.<br/></div></body></html>