<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"></head><body><h2 class="header"><a href="../../../std/core/array/index.html">Overview</a>&nbsp<a href="../../../std/core/array/globals.html">Globals</a>&nbsp<a href="../../../std/core/array/types.html">Types</a>&nbsp<span class="selected">Functions</span>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">array</span></h1></div><h1>Public</h1><h2 id="@tzip">@tzip</h2>Array &apos;zip&apos; using the temp allocator.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@tzip</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="index_of">index_of</h2>Return the first index of element found in the array, searching from the start.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">index_of</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="@zip">@zip</h2>Zip together two separate arrays/slices into a single array of Pairs or return values. Values will<br/>be collected up to the length of the shorter array if `fill_with` is left undefined; otherwise, they<br/>will be collected up to the length of the LONGER array, with missing values in the shorter array being<br/>assigned to the value of `fill_with`. Return array elements do not have to be of the same type.<br/><br/>For example:<br/>```c3<br/>uint[] chosen_session_ids = server::get_random_sessions(instance)[:128];<br/>String[200] refreshed_session_keys = prng::new_keys_batch();<br/><br/>Pair { uint, String }[] sessions_meta = array::zip(mem, chosen_session_ids, refreshed_session_keys);<br/>// The resulting Pair{}[] slice is then length of the shortest of the two arrays, so 128.<br/><br/>foreach (i, &amp;sess : sessions:meta) {<br/>    // distribute new session keys to associated instance IDs<br/>}<br/>```<br/><br/>Or:<br/>```c3<br/>String[] client_names = server::online_usernames(instance);<br/>uint128[] session_ids = server::user_keys();<br/><br/>// in this example, we &apos;know&apos; ahead of time that &apos;session_ids&apos; can only ever be SHORTER<br/>//   than &apos;client_names&apos;, but never longer, because it&apos;s possible new users have logged<br/>//   in without getting whatever this &apos;session ID&apos; is delegated to them.<br/>Pair { String, uint128 }[] zipped = array::tzip(client_names, session_ids, fill_with: uint128.max);<br/><br/>server::refresh_session_keys_by_pair(zipped)!;<br/>```<br/><br/>### When an `operation` is supplied...<br/>Apply an operation to each element of two slices or arrays and return the results of<br/>each operation into a newly allocated array.<br/><br/>This essentially combines Iterable1 with Iterable2 using the `operation` functor.<br/><br/>See the functional `zipWith` construct, which has a more appropriate name than, e.g., `map`;<br/>  a la: https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:zipWith<br/><br/>Similar to &quot;normal&quot; `zip`, this macro pads the shorter input array with a given `fill_with`, or<br/>an empty value if one isn&apos;t supplied. This `fill_with` is supplied to the `operation` functor<br/>_BEFORE_ calculating its result while zipping.<br/><br/>For example: a functor of `fn char (char a, char b) =&gt; a + b` with a `fill_with` of 7,<br/>where the `left` array is the shorter iterable, will put 7 into that lambda in each place<br/>where `left` is being filled in during the zip operation.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@zip</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">allocator</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="find_len">find_len</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_FUNCTION DataType">find_len</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">list</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="tconcat">tconcat</h2>Concatenate two arrays or slices, returning a slice containing the concatenation of them,<br/>allocated using the temp allocator.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">tconcat</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">arr1</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr2</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="concat">concat</h2>Concatenate two arrays or slices, returning a slice containing the concatenation of them.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">concat</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">allocator</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr1</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr2</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="rindex_of">rindex_of</h2>Return the first index of element found in the array, searching in reverse from the end.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">rindex_of</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="contains">contains</h2>Returns true if the array contains at least one element, else false<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">contains</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="@zip_into">@zip_into</h2>Apply an operation to each element of two slices or arrays and store the results of<br/>each operation into the &apos;left&apos; value.<br/><br/>This is useful because no memory allocations are required in order to perform the operation.<br/><br/>A good example of using this might be using algorithmic transformations on data in-place:<br/>```<br/>char[] partial_cipher = get_next_plaintext_block();<br/><br/>array::@zip_into(<br/>    partial_cipher[ENCRYPT_OFFSET:BASE_KEY.len],<br/>	 BASE_KEY,<br/>	 fn char (char a, char b) =&gt; a ^ (b * 5) % 37<br/>);<br/>```<br/><br/>This parameterizes the lambda function with left (`partial_cipher`) and right (`BASE_KEY`) slice<br/>elements and stores the end result in-place within the left slice. This is in contrast to a<br/>regular `zip_with` which will create a cloned final result and return it.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@zip_into</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="slice2d">slice2d</h2>Slice a 2d array and create a Slice2d from it.<br/><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">slice2d</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array_ptr</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">x</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">xlen</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">y</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">ylen</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h1>Private</h1><h2 id="@is_valid_list">@is_valid_list</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_list</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#expr</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@const</span> <span class="DataType_IDENT DataType">@private</span></code></pre><h2 id="@is_valid_operation">@is_valid_operation</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_operation</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#operation</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#right</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@const</span> <span class="DataType_IDENT DataType">@private</span></code></pre><h2 id="@zip_into_fn">@zip_into_fn</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">typeid</span> <span class="DataType_FUNCTION DataType">@zip_into_fn</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#right</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@private</span> <span class="DataType_IDENT DataType">@const</span></code></pre><h2 id="@is_valid_fill">@is_valid_fill</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_fill</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@private</span></code></pre></body></html>