<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"></head><body><h2 class="header"><a href="../../../std/core/array/index.html">Overview</a>&nbsp<a href="../../../std/core/array/globals.html">Globals</a>&nbsp<a href="../../../std/core/array/types.html">Types</a>&nbsp<span class="selected">Functions</span>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">array</span></h1></div><h1>Public</h1><h2 id="@tzip">@tzip</h2>Array &apos;zip&apos; using the temp allocator.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@tzip</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="index_of">index_of</h2>Return the first index of element found in the array, searching from the start.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">index_of</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="@zip">@zip</h2>Zip together two separate arrays/slices into a single array of Pairs or return values. Values willbe collected up to the length of the shorter array if `fill_with` is left undefined; otherwise, theywill be collected up to the length of the LONGER array, with missing values in the shorter array beingassigned to the value of `fill_with`. Return array elements do not have to be of the same type.For example:```c3uint[] chosen_session_ids = server::get_random_sessions(instance)[:128];String[200] refreshed_session_keys = prng::new_keys_batch();Pair { uint, String }[] sessions_meta = array::zip(mem, chosen_session_ids, refreshed_session_keys);// The resulting Pair{}[] slice is then length of the shortest of the two arrays, so 128.foreach (i, &amp;sess : sessions:meta) {    // distribute new session keys to associated instance IDs}```Or:```c3String[] client_names = server::online_usernames(instance);uint128[] session_ids = server::user_keys();// in this example, we &apos;know&apos; ahead of time that &apos;session_ids&apos; can only ever be SHORTER//   than &apos;client_names&apos;, but never longer, because it&apos;s possible new users have logged//   in without getting whatever this &apos;session ID&apos; is delegated to them.Pair { String, uint128 }[] zipped = array::tzip(client_names, session_ids, fill_with: uint128.max);server::refresh_session_keys_by_pair(zipped)!;```### When an `operation` is supplied...Apply an operation to each element of two slices or arrays and return the results ofeach operation into a newly allocated array.This essentially combines Iterable1 with Iterable2 using the `operation` functor.See the functional `zipWith` construct, which has a more appropriate name than, e.g., `map`;  a la: https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:zipWithSimilar to &quot;normal&quot; `zip`, this macro pads the shorter input array with a given `fill_with`, oran empty value if one isn&apos;t supplied. This `fill_with` is supplied to the `operation` functor_BEFORE_ calculating its result while zipping.For example: a functor of `fn char (char a, char b) =&gt; a + b` with a `fill_with` of 7,where the `left` array is the shorter iterable, will put 7 into that lambda in each placewhere `left` is being filled in during the zip operation.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@zip</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">allocator</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_CONST DataType">EMPTY_MACRO_SLOT</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="find_len">find_len</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_FUNCTION DataType">find_len</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">list</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="tconcat">tconcat</h2>Concatenate two arrays or slices, returning a slice containing the concatenation of them,allocated using the temp allocator.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">tconcat</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">arr1</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr2</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="concat">concat</h2>Concatenate two arrays or slices, returning a slice containing the concatenation of them.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">concat</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">allocator</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr1</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">arr2</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@nodiscard</span></code></pre><h2 id="rindex_of">rindex_of</h2>Return the first index of element found in the array, searching in reverse from the end.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">rindex_of</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="contains">contains</h2>Returns true if the array contains at least one element, else false<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">contains</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">element</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="@zip_into">@zip_into</h2>Apply an operation to each element of two slices or arrays and store the results ofeach operation into the &apos;left&apos; value.This is useful because no memory allocations are required in order to perform the operation.A good example of using this might be using algorithmic transformations on data in-place:```char[] partial_cipher = get_next_plaintext_block();array::@zip_into(    partial_cipher[ENCRYPT_OFFSET:BASE_KEY.len],	 BASE_KEY,	 fn char (char a, char b) =&gt; a ^ (b * 5) % 37);```This parameterizes the lambda function with left (`partial_cipher`) and right (`BASE_KEY`) sliceelements and stores the end result in-place within the left slice. This is in contrast to aregular `zip_with` which will create a cloned final result and return it.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">@zip_into</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#operation</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h2 id="slice2d">slice2d</h2>Slice a 2d array and create a Slice2d from it.<pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_FUNCTION DataType">slice2d</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">array_ptr</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">x</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">xlen</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">y</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">ylen</span> <span class="DataType_DEFAULT DataType">=</span> <span class="DataType_NUMBER DataType">0</span><span class="DataType_DEFAULT DataType">)</span></code></pre><h1>Private</h1><h2 id="@is_valid_list">@is_valid_list</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_list</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#expr</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@const</span> <span class="DataType_IDENT DataType">@private</span></code></pre><h2 id="@is_valid_operation">@is_valid_operation</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_operation</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#operation</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#right</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@const</span> <span class="DataType_IDENT DataType">@private</span></code></pre><h2 id="@zip_into_fn">@zip_into_fn</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">typeid</span> <span class="DataType_FUNCTION DataType">@zip_into_fn</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">#left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">#right</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@private</span> <span class="DataType_IDENT DataType">@const</span></code></pre><h2 id="@is_valid_fill">@is_valid_fill</h2><pre><code><span class="DataType_KEYWORD DataType">macro</span> <span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_FUNCTION DataType">@is_valid_fill</span><span class="DataType_DEFAULT DataType">(</span><span class="DataType_IDENT DataType">left</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">right</span><span class="DataType_DEFAULT DataType">,</span> <span class="DataType_IDENT DataType">fill_with</span><span class="DataType_DEFAULT DataType">)</span> <span class="DataType_IDENT DataType">@private</span></code></pre></body></html>