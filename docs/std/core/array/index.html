<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"></head><body><h2 class="header"><span class="selected">Overview</span>&nbsp<a href="../../../std/core/array/globals.html">Globals</a>&nbsp<a href="../../../std/core/array/types.html">Types</a>&nbsp<a href="../../../std/core/array/functions.html">Functions</a>&nbsp<a href="../../../std/core/array/type.%s.html">Type</a>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">array</span></h1></div><h2>Submodules</h2><a href="../../../std/core/array/slice/index.html">slice</a>&nbsp<h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/array/functions.html#@tzip">array::@tzip</a></td><td>Array &apos;zip&apos; using the temp allocator.</td></tr><tr><td><a href="../../../std/core/array/functions.html#index_of">array::index_of</a></td><td>Return the first index of element found in the array, searching from the start.</td></tr><tr><td><a href="../../../std/core/array/functions.html#@zip">array::@zip</a></td><td>Zip together two separate arrays/slices into a single array of Pairs or return values. Values will...</td></tr><tr><td><a href="../../../std/core/array/functions.html#find_len">array::find_len</a></td><td></td></tr><tr><td><a href="../../../std/core/array/functions.html#tconcat">array::tconcat</a></td><td>Concatenate two arrays or slices, returning a slice containing the concatenation of them,...</td></tr><tr><td><a href="../../../std/core/array/functions.html#concat">array::concat</a></td><td>Concatenate two arrays or slices, returning a slice containing the concatenation of them.</td></tr><tr><td><a href="../../../std/core/array/functions.html#rindex_of">array::rindex_of</a></td><td>Return the first index of element found in the array, searching in reverse from the end.</td></tr><tr><td><a href="../../../std/core/array/functions.html#contains">array::contains</a></td><td>Returns true if the array contains at least one element, else false</td></tr><tr><td><a href="../../../std/core/array/functions.html#@zip_into">array::@zip_into</a></td><td>Apply an operation to each element of two slices or arrays and store the results of...</td></tr><tr><td><a href="../../../std/core/array/functions.html#slice2d">array::slice2d</a></td><td>Slice a 2d array and create a Slice2d from it.</td></tr></table><h2>Private</h2><h3>Functions</h3><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/array/functions.html#@is_valid_list">array::@is_valid_list</a></td><td></td></tr><tr><td><a href="../../../std/core/array/functions.html#@is_valid_operation">array::@is_valid_operation</a></td><td></td></tr><tr><td><a href="../../../std/core/array/functions.html#@zip_into_fn">array::@zip_into_fn</a></td><td></td></tr><tr><td><a href="../../../std/core/array/functions.html#@is_valid_fill">array::@is_valid_fill</a></td><td></td></tr></table></body></html>