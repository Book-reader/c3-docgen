<!DOCTYPE html><html><head><link rel="stylesheet" href="../../../style.css"><script src="../../../main.js"></script></head><body><div class="main"><div class="module_path"><h1><a href="../../../std/index.html" target="_parent">std</a>::<a href="../../../std/core/index.html" target="_parent">core</a>::<span style="font-family: 'monospace'">array</span></h1></div><h1>@zip_into</h1>Apply an operation to each element of two slices or arrays and store the results of<br/>each operation into the &apos;left&apos; value.<br/><br/>This is useful because no memory allocations are required in order to perform the operation.<br/><br/>A good example of using this might be using algorithmic transformations on data in-place:<br/>```<br/>char[] partial_cipher = get_next_plaintext_block();<br/><br/>array::@zip_into(<br/>    partial_cipher[ENCRYPT_OFFSET:BASE_KEY.len],<br/>	 BASE_KEY,<br/>	 fn char (char a, char b) =&gt; a ^ (b * 5) % 37<br/>);<br/>```<br/><br/>This parameterizes the lambda function with left (`partial_cipher`) and right (`BASE_KEY`) slice<br/>elements and stores the end result in-place within the left slice. This is in contrast to a<br/>regular `zip_with` which will create a cloned final result and return it.<br/></div></body></html>