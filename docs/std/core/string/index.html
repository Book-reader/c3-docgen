<!DOCTYPE html><html><head><link rel="stylesheet" href="../../../style.css"></head><body><iframe class="sidebar" src="./sidebar.html" scrolling="no"></iframe><div class="main"><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">string</span></h1></div><h2>Submodules</h2><a href="../../../std/core/string/iterator/index.html">iterator</a>&nbsp<a href="../../../std/core/string/conv/index.html">conv</a>&nbsp<a href="../../../std/core/string/ansi/index.html">ansi</a>&nbsp<h2>Public</h2><h2>Types</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/string/type.Splitter.html">Splitter</a></td><td>Splitter is handles tokenizing strings.</td></tr><tr><td><a href="../../../std/core/string/type.SplitterType.html">SplitterType</a></td><td></td></tr></table><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/string/fn.tokenize_all.html">string::tokenize_all</a></td><td>Create a Splitter to track tokenizing of a string. Tokenize will turn &quot;foo:bar::baz&quot; into...</td></tr><tr><td><a href="../../../std/core/string/fn.treplace.html">string::treplace</a></td><td>Replace all instances of one substring with a different string, allocating the new string on the temp allocator.</td></tr><tr><td><a href="../../../std/core/string/fn.str_view.html">string::str_view</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_ulong.html">string::to_ulong</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_upper_tcopy.html">string::to_upper_tcopy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.tsplit.html">string::tsplit</a></td><td>This function is identical to String.split, but implicitly uses the...</td></tr><tr><td><a href="../../../std/core/string/fn.tfrom_struct.html">string::tfrom_struct</a></td><td>This macro will create a temporary string description of a struct.</td></tr><tr><td><a href="../../../std/core/string/fn.len.html">string::len</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.next.html">string::next</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.strip_end.html">string::strip_end</a></td><td>Strip the end of the string if the suffix exists.</td></tr><tr><td><a href="../../../std/core/string/fn.snake_to_pascal_copy.html">string::snake_to_pascal_copy</a></td><td>Convert a string from `snake_case` to PascalCase.</td></tr><tr><td><a href="../../../std/core/string/fn.strip.html">string::strip</a></td><td>Strip the front of the string if the prefix exists.</td></tr><tr><td><a href="../../../std/core/string/fn.quick_zstr.html">string::quick_zstr</a></td><td>Return a pointer to the string *iff* it is a pointer...</td></tr><tr><td><a href="../../../std/core/string/fn.@char32.html">string::@char32</a></td><td>Create a slice of an UTF32 encoded string at compile time.</td></tr><tr><td><a href="../../../std/core/string/fn.convert_to_lower.html">string::convert_to_lower</a></td><td>Convert a string to ASCII lower case in place.</td></tr><tr><td><a href="../../../std/core/string/fn.tcopy.html">string::tcopy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.@wstring32.html">string::@wstring32</a></td><td>Create a pointer to an UTF32 encoded string at compile time.</td></tr><tr><td><a href="../../../std/core/string/fn.@sprintf.html">string::@sprintf</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.format.html">string::format</a></td><td>Return a new String created using the formatting function.</td></tr><tr><td><a href="../../../std/core/string/fn.to_utf16.html">string::to_utf16</a></td><td>Convert an UTF-8 string to UTF-16</td></tr><tr><td><a href="../../../std/core/string/fn.contains.html">string::contains</a></td><td>Check if a substring is found in the string.</td></tr><tr><td><a href="../../../std/core/string/fn.trim.html">string::trim</a></td><td>Remove characters from the front and end of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.capitalize_copy.html">string::capitalize_copy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_utf32.html">string::to_utf32</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.escape.html">string::escape</a></td><td>Escape a string by adding quotes and converting special characters to escape sequences.</td></tr><tr><td><a href="../../../std/core/string/fn.join.html">string::join</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.tfrom_wstring.html">string::tfrom_wstring</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_int.html">string::to_int</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.zstr_copy.html">string::zstr_copy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.is_zstr.html">string::is_zstr</a></td><td>Determine whether the current string actually points to a ZString-like string....</td></tr><tr><td><a href="../../../std/core/string/fn.utf8_codepoints.html">string::utf8_codepoints</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_wstring.html">string::to_wstring</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.pascal_to_snake_copy.html">string::pascal_to_snake_copy</a></td><td>Convert a string from `PascalCase` to `snake_case`.</td></tr><tr><td><a href="../../../std/core/string/fn.concat.html">string::concat</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.ends_with.html">string::ends_with</a></td><td>Check if the String ends with the suffix.</td></tr><tr><td><a href="../../../std/core/string/fn.free.html">string::free</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_temp_wstring.html">string::to_temp_wstring</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.from_struct.html">string::from_struct</a></td><td>This macro will create a string description of a struct.</td></tr><tr><td><a href="../../../std/core/string/fn.to_uint.html">string::to_uint</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.tfrom_utf16.html">string::tfrom_utf16</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_ichar.html">string::to_ichar</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.iterator.html">string::iterator</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.tformat.html">string::tformat</a></td><td>Return a temporary String created using the formatting function.</td></tr><tr><td><a href="../../../std/core/string/fn.index_of.html">string::index_of</a></td><td>Find the index of the first incidence of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.to_temp_utf16.html">string::to_temp_utf16</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.decfloat.html">string::decfloat</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.unescape.html">string::unescape</a></td><td>Unescape a quoted string by parsing escape sequences.</td></tr><tr><td><a href="../../../std/core/string/fn.char_len.html">string::char_len</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.rindex_of.html">string::rindex_of</a></td><td>Find the index of the last incidence of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.to_long.html">string::to_long</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_upper_copy.html">string::to_upper_copy</a></td><td>Returns a string converted to ASCII upper case.</td></tr><tr><td><a href="../../../std/core/string/fn.index_of_chars.html">string::index_of_chars</a></td><td>Find the index of the first incidence of a one of the chars.</td></tr><tr><td><a href="../../../std/core/string/fn.reset.html">string::reset</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.contains_char.html">string::contains_char</a></td><td>Check if a character is found in the string.</td></tr><tr><td><a href="../../../std/core/string/fn.split_to_buffer.html">string::split_to_buffer</a></td><td>Split a string into parts, e.g &quot;a|b|c&quot; split with &quot;|&quot; yields { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }</td></tr><tr><td><a href="../../../std/core/string/fn.tokenize.html">string::tokenize</a></td><td>Create a Splitter to track tokenizing of a string. Tokenize will turn &quot;foo:bar::baz&quot; into...</td></tr><tr><td><a href="../../../std/core/string/fn.to_float.html">string::to_float</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_int128.html">string::to_int128</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.tunescape.html">string::tunescape</a></td><td>Unescape a quoted string using the temp allocator.</td></tr><tr><td><a href="../../../std/core/string/fn.tformat_zstr.html">string::tformat_zstr</a></td><td>Return a temporary ZString created using the formatting function.</td></tr><tr><td><a href="../../../std/core/string/fn.char_in_set.html">string::char_in_set</a></td><td>Check if a character is in a set.</td></tr><tr><td><a href="../../../std/core/string/fn.split.html">string::split</a></td><td>Split a string into parts, e.g &quot;a|b|c&quot; split with &quot;|&quot; yields { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }</td></tr><tr><td><a href="../../../std/core/string/fn.to_lower_copy.html">string::to_lower_copy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.rindex_of_char.html">string::rindex_of_char</a></td><td>Find the index of the first incidence of a character starting from the end.</td></tr><tr><td><a href="../../../std/core/string/fn.eq.html">string::eq</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.convert_to_upper.html">string::convert_to_upper</a></td><td>Convert a string to ASCII upper case.</td></tr><tr><td><a href="../../../std/core/string/fn.to_uint128.html">string::to_uint128</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.needs_escape.html">string::needs_escape</a></td><td>Check if a character needs to be escaped in a string literal.</td></tr><tr><td><a href="../../../std/core/string/fn.splitter.html">string::splitter</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.copy.html">string::copy</a></td><td>Copy this string, by duplicating the string, always adding a zero byte...</td></tr><tr><td><a href="../../../std/core/string/fn.@char16.html">string::@char16</a></td><td>Create a slice of an UTF32 encoded string at compile time.</td></tr><tr><td><a href="../../../std/core/string/fn.trim_left.html">string::trim_left</a></td><td>Remove characters from the front of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.to_ushort.html">string::to_ushort</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.from_utf16.html">string::from_utf16</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.from_utf32.html">string::from_utf32</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_integer.html">string::to_integer</a></td><td>Convert a number to a given base. If the base is not given, then...</td></tr><tr><td><a href="../../../std/core/string/fn.to_uchar.html">string::to_uchar</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.replace.html">string::replace</a></td><td>Replace all instances of one substring with a different string.</td></tr><tr><td><a href="../../../std/core/string/fn.to_short.html">string::to_short</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.starts_with.html">string::starts_with</a></td><td>Check if the String starts with the prefix.</td></tr><tr><td><a href="../../../std/core/string/fn.count.html">string::count</a></td><td>Check how many non-overlapping instances of a substring there is....</td></tr><tr><td><a href="../../../std/core/string/fn.trim_right.html">string::trim_right</a></td><td>Remove characters from the end of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.escape_len.html">string::escape_len</a></td><td>Calculate the length needed for an escaped string (including quotes).</td></tr><tr><td><a href="../../../std/core/string/fn.index_of_char.html">string::index_of_char</a></td><td>Find the index of the first incidence of a string.</td></tr><tr><td><a href="../../../std/core/string/fn.from_wstring.html">string::from_wstring</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.convert_snake_to_pascal.html">string::convert_snake_to_pascal</a></td><td>Movifies the current string from `snake_case` to PascalCase.</td></tr><tr><td><a href="../../../std/core/string/fn.@wstring.html">string::@wstring</a></td><td>Create a WString (an UTF16 encoded string) at compile time.</td></tr><tr><td><a href="../../../std/core/string/fn.tconcat.html">string::tconcat</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_double.html">string::to_double</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.to_temp_utf32.html">string::to_temp_utf32</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.hexfloat.html">string::hexfloat</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.zstr_tcopy.html">string::zstr_tcopy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.index_of_char_from.html">string::index_of_char_from</a></td><td>Find the index of the first incidence of a character.</td></tr><tr><td><a href="../../../std/core/string/fn.tescape.html">string::tescape</a></td><td>Escape a string using the temp allocator.</td></tr><tr><td><a href="../../../std/core/string/fn.to_lower_tcopy.html">string::to_lower_tcopy</a></td><td></td></tr><tr><td><a href="../../../std/core/string/fn.bformat.html">string::bformat</a></td><td>Return a new String created using the formatting function.</td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/string/global.B1B_DIG.html">B1B_DIG</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.B1B_MAX.html">B1B_MAX</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.MASK.html">MASK</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.KMAX.html">KMAX</a></td><td></td></tr></table><h2>Private</h2><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/string/fn.to_real.html">string::to_real</a></td><td></td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_LOW_VALUE.html">SURROGATE_LOW_VALUE</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_CODEPOINT_MASK.html">SURROGATE_CODEPOINT_MASK</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_BITS.html">SURROGATE_BITS</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_HIGH_VALUE.html">SURROGATE_HIGH_VALUE</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_MASK.html">SURROGATE_MASK</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_GENERIC_MASK.html">SURROGATE_GENERIC_MASK</a></td><td></td></tr><tr><td><a href="../../../std/core/string/global.SURROGATE_OFFSET.html">SURROGATE_OFFSET</a></td><td></td></tr></table></div></body></html>