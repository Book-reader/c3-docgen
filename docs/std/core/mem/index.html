<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"></head><body><h2 class="header"><span class="selected">Overview</span>&nbsp<a href="../../../std/core/mem/globals.html">Globals</a>&nbsp<a href="../../../std/core/mem/types.html">Types</a>&nbsp<a href="../../../std/core/mem/functions.html">Functions</a>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">mem</span></h1></div><h2>Submodules</h2><a href="../../../std/core/mem/volatile/index.html">volatile</a>&nbsp<a href="../../../std/core/mem/vm/index.html">vm</a>&nbsp<a href="../../../std/core/mem/ref/index.html">ref</a>&nbsp<a href="../../../std/core/mem/rc/index.html">rc</a>&nbsp<a href="../../../std/core/mem/mempool/index.html">mempool</a>&nbsp<a href="../../../std/core/mem/allocator/index.html">allocator</a>&nbsp<a href="../../../std/core/mem/alignment/index.html">alignment</a>&nbsp<h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/functions.html#@tclone_slice">mem::@tclone_slice</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_array">mem::new_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#aligned_pointer">mem::aligned_pointer</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@stack_pool">mem::@stack_pool</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#clear_inline">mem::clear_inline</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#realloc">mem::realloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@masked_load_aligned">mem::@masked_load_aligned</a></td><td>Load a vector from memory according to a mask.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#masked_store">mem::masked_store</a></td><td>Store parts of a vector according to the mask, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#malloc_aligned">mem::malloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@pool_init">mem::@pool_init</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#tnew">mem::tnew</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#copy_inline">mem::copy_inline</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap, it...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#equals">mem::equals</a></td><td>Test if n elements are equal in a slice, pointed to by a pointer etc.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#free_aligned">mem::free_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#set_inline">mem::set_inline</a></td><td>Sets all memory in a region to that of the provided byte. Never calls OS memset.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#tmalloc">mem::tmalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#calloc_aligned">mem::calloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_store">mem::@unaligned_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#type_alloc_must_be_aligned">mem::type_alloc_must_be_aligned</a></td><td>Check if an allocation must be aligned given the type.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memcpy">mem::__memcpy</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@report_heap_allocs_in_scope">mem::@report_heap_allocs_in_scope</a></td><td>Run the tracking allocator in the scope, then...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#move">mem::move</a></td><td>Copy memory from src to dst but correctly handle the possibility of overlapping ranges.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#trealloc">mem::trealloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@clone_aligned">mem::@clone_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_aligned">mem::new_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#aligned_offset">mem::aligned_offset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#get_tracking_env">mem::get_tracking_env</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#free">mem::free</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc_array">mem::talloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new">mem::new</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_array_aligned">mem::new_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@atomic_load">mem::@atomic_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#set">mem::set</a></td><td>Sets all memory in a region to that of the provided byte.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@scoped">mem::@scoped</a></td><td>Run with a specific allocator inside of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@clone_slice">mem::@clone_slice</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@volatile_load">mem::@volatile_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@assert_leak">mem::@assert_leak</a></td><td>Assert on memory leak in the scope of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#ptr_is_aligned">mem::ptr_is_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#compare_exchange_volatile">mem::compare_exchange_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_array">mem::temp_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_with_padding">mem::alloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@clone">mem::@clone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_array">mem::alloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_array_aligned">mem::alloc_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_with_padding">mem::new_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@masked_store_aligned">mem::@masked_store_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#os_pagesize">mem::os_pagesize</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@scatter_aligned">mem::@scatter_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#realloc_aligned">mem::realloc_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_pop">mem::temp_pop</a></td><td>Pop the current temp allocator. A pop must always be balanced with a push.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc_with_padding">mem::talloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@volatile_store">mem::@volatile_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#calloc">mem::calloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#zero_volatile">mem::zero_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#clear">mem::clear</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#copy">mem::copy</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#masked_load">mem::masked_load</a></td><td>Load a vector from memory according to a mask assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@pool">mem::@pool</a></td><td>Create a new temporary allocator....</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@atomic_store">mem::@atomic_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_with_padding">mem::temp_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#gather">mem::gather</a></td><td>Load values from a pointer vector, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_load">mem::@unaligned_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@stack_mem">mem::@stack_mem</a></td><td>Allocate [size] bytes on the stack to use for allocation,...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#ptr_is_page_aligned">mem::ptr_is_page_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc">mem::talloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@tclone">mem::@tclone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memset">mem::__memset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@gather_aligned">mem::@gather_aligned</a></td><td>Load values from a pointer vector.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memcmp">mem::__memcmp</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#compare_exchange">mem::compare_exchange</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#scatter">mem::scatter</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_addr">mem::@unaligned_addr</a></td><td>Takes the address of a possibly unaligned variable or member,...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#tcalloc">mem::tcalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#malloc">mem::malloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc">mem::alloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_aligned">mem::alloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_push">mem::temp_push</a></td><td>Push the current temp allocator. A push must always be balanced with a pop using the current state.</td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/globals.html#__heap_base">__heap_base</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#KB">KB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#MB">MB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#GB">GB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#DEFAULT_MEM_ALIGNMENT">DEFAULT_MEM_ALIGNMENT</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#TB">TB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#MAX_MEMORY_ALIGNMENT">MAX_MEMORY_ALIGNMENT</a></td><td></td></tr></table><h2>Types</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/types.html#AtomicOrdering">AtomicOrdering</a></td><td></td></tr></table><h2>Private</h2><h3>Functions</h3><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/functions.html#initialize_wasm_mem">mem::initialize_wasm_mem</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@constant_is_power_of_2">mem::@constant_is_power_of_2</a></td><td></td></tr></table><h3>Globals</h3><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/globals.html#wasm_allocator">wasm_allocator</a></td><td></td></tr></table></body></html>