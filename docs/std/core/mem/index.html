<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../style.css"><style>../../../style.css</style></head><body><h2 class="header"><span class="selected">Overview</span>&nbsp<a href="../../../std/core/mem/globals.html">Globals</a>&nbsp<a href="../../../std/core/mem/types.html">Types</a>&nbsp<a href="../../../std/core/mem/functions.html">Functions</a>&nbsp</h2><div class="module_path"><h1><a href="../../../std/index.html">std</a>::<a href="../../../std/core/index.html">core</a>::<span style="font-family: 'monospace'">mem</span></h1></div><h2>Submodules</h2><a href="../../../std/core/mem/volatile/index.html">volatile</a>&nbsp<a href="../../../std/core/mem/vm/index.html">vm</a>&nbsp<a href="../../../std/core/mem/ref/index.html">ref</a>&nbsp<a href="../../../std/core/mem/rc/index.html">rc</a>&nbsp<a href="../../../std/core/mem/mempool/index.html">mempool</a>&nbsp<a href="../../../std/core/mem/allocator/index.html">allocator</a>&nbsp<a href="../../../std/core/mem/alignment/index.html">alignment</a>&nbsp<h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/globals.html#__heap_base">__heap_base</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#KB">KB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#MB">MB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#GB">GB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#DEFAULT_MEM_ALIGNMENT">DEFAULT_MEM_ALIGNMENT</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#TB">TB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/globals.html#MAX_MEMORY_ALIGNMENT">MAX_MEMORY_ALIGNMENT</a></td><td></td></tr></table><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/functions.html#new_array">mem::new_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#aligned_pointer">mem::aligned_pointer</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@stack_pool">@stack_pool</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#clear_inline">mem::clear_inline</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#realloc">realloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@masked_load_aligned">mem::@masked_load_aligned</a></td><td>Load a vector from memory according to a mask.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#masked_store">mem::masked_store</a></td><td>Store parts of a vector according to the mask, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#malloc_aligned">malloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@pool_init">@pool_init</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#tnew">mem::tnew</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#copy_inline">mem::copy_inline</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap, itwill always be inlined and never call memcopy</td></tr><tr><td><a href="../../../std/core/mem/functions.html#equals">mem::equals</a></td><td>Test if n elements are equal in a slice, pointed to by a pointer etc.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#free_aligned">free_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#set_inline">mem::set_inline</a></td><td>Sets all memory in a region to that of the provided byte. Never calls OS memset.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#tmalloc">tmalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#calloc_aligned">calloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_store">@unaligned_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#type_alloc_must_be_aligned">mem::type_alloc_must_be_aligned</a></td><td>Check if an allocation must be aligned given the type.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memcpy">mem::__memcpy</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@report_heap_allocs_in_scope">mem::@report_heap_allocs_in_scope</a></td><td>Run the tracking allocator in the scope, thenprint out stats.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#move">mem::move</a></td><td>Copy memory from src to dst but correctly handle the possibility of overlapping ranges.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#trealloc">trealloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@clone_aligned">@clone_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_aligned">mem::new_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#aligned_offset">mem::aligned_offset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#get_tracking_env">mem::get_tracking_env</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#free">free</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc_array">mem::talloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new">mem::new</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_array_aligned">mem::new_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@atomic_load">@atomic_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#set">mem::set</a></td><td>Sets all memory in a region to that of the provided byte.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@scoped">mem::@scoped</a></td><td>Run with a specific allocator inside of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@volatile_load">@volatile_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@assert_leak">@assert_leak</a></td><td>Assert on memory leak in the scope of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#ptr_is_aligned">mem::ptr_is_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#compare_exchange_volatile">mem::compare_exchange_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_array">mem::temp_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_with_padding">mem::alloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@clone">@clone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_array">mem::alloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_array_aligned">mem::alloc_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#new_with_padding">mem::new_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@masked_store_aligned">mem::@masked_store_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#os_pagesize">mem::os_pagesize</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@scatter_aligned">mem::@scatter_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#realloc_aligned">realloc_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_pop">mem::temp_pop</a></td><td>Pop the current temp allocator. A pop must always be balanced with a push.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc_with_padding">mem::talloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@volatile_store">@volatile_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#calloc">calloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#zero_volatile">mem::zero_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#clear">mem::clear</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#copy">mem::copy</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#masked_load">mem::masked_load</a></td><td>Load a vector from memory according to a mask assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@pool">@pool</a></td><td>Create a new temporary allocator.The `reserve` parameter allows you to determine how many bytes should be reserved forallocations on the current temporary allocator, if allocations are made inside of the pool scope.It is made available for optimization, and can usually be ignored.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@atomic_store">@atomic_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_with_padding">mem::temp_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#gather">mem::gather</a></td><td>Load values from a pointer vector, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_load">@unaligned_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@stack_mem">@stack_mem</a></td><td>Allocate [size] bytes on the stack to use for allocation,with the heap allocator as the backing allocator.Release everything on scope exit.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#ptr_is_page_aligned">mem::ptr_is_page_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#talloc">mem::talloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@tclone">@tclone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memset">mem::__memset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@gather_aligned">mem::@gather_aligned</a></td><td>Load values from a pointer vector.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#__memcmp">mem::__memcmp</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#compare_exchange">mem::compare_exchange</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#scatter">mem::scatter</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#@unaligned_addr">@unaligned_addr</a></td><td>Takes the address of a possibly unaligned variable or member,and offers safe access to that member, by constructing an UnalignedRef.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#tcalloc">tcalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#malloc">malloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc">mem::alloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/functions.html#alloc_aligned">mem::alloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignmentexceeding DEFAULT_MEM_ALIGNMENT. IMPORTANT! It must be freed using free_aligned.</td></tr><tr><td><a href="../../../std/core/mem/functions.html#temp_push">mem::temp_push</a></td><td>Push the current temp allocator. A push must always be balanced with a pop using the current state.</td></tr></table><h2>Private</h2><h3>Globals</h3><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="#todo">wasm_allocator</a></td><td>TODO</td></tr></table><h3>Functions</h3><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="#todo">mem::initialize_wasm_mem</a></td><td>TODO</td></tr><tr><td><a href="#todo">mem::@constant_is_power_of_2</a></td><td>TODO</td></tr></table></body></html>