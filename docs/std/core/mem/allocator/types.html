<!DOCTYPE html><html style = "font-family:'0xProto Nerd Font'"><head><link rel="stylesheet" href="../../../../style.css"></head><body><h2 class="header"><a href="../../../../std/core/mem/allocator/index.html">Overview</a>&nbsp<a href="../../../../std/core/mem/allocator/globals.html">Globals</a>&nbsp<span class="selected">Types</span>&nbsp<a href="../../../../std/core/mem/allocator/functions.html">Functions</a>&nbsp</h2><div class="module_path"><h1><a href="../../../../std/index.html">std</a>::<a href="../../../../std/core/index.html">core</a>::<a href="../../../../std/core/mem/index.html">mem</a>::<span style="font-family: 'monospace'">allocator</span></h1></div><h1>Public</h1><h2 id="SimpleHeapAllocator">SimpleHeapAllocator</h2>The SimpleHeapAllocator implements a simple heap allocator on top of an allocator function.It uses the given allocator function to allocate memory from some source, but never frees it.This allocator is intended to be used in environments where there isn&apos;t any native libc malloc,and it has to be emulated from a memory region, or wrapping linear memory as is the case for plain WASM.<pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">SimpleHeapAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">MemoryAllocFn</span> <span class="DataType_IDENT DataType">alloc_fn</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">Header</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">free_list</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="TrackingAllocator">TrackingAllocator</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">TrackingAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">inner_allocator</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">AllocMap</span> <span class="DataType_IDENT DataType">map</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">mem_total</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">allocs_total</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="OnStackAllocator">OnStackAllocator</h2>The OnStackAllocator is similar to the ArenaAllocator: it allocates from a chunk of memorygiven to it.The difference is that when it runs out of memory it will go directly to its backing allocatorrather than failing.It is utilized by the @stack_mem macro as an alternative to the temp allocator.<pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">OnStackAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">backing_allocator</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">used</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">OnStackAllocatorExtraChunk</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">chunk</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="TempAllocator">TempAllocator</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">TempAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">backing_allocator</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">TempAllocatorPage</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">last_page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">TempAllocator</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">derived</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">bool</span> <span class="DataType_IDENT DataType">allocated</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">reserve_size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">realloc_size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">min_size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">used</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">capacity</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">original_capacity</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">*</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">TempAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Vmem</span> <span class="DataType_IDENT DataType">vmem</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">TempAllocator</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">derived</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">allocator</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="TempAllocatorPage">TempAllocatorPage</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">TempAllocatorPage</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">TempAllocatorPage</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">prev_page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">void</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">start</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">ident</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">*</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="AlignedBlock">AlignedBlock</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">AlignedBlock</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">len</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">void</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">start</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="WasmMemory">WasmMemory</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">WasmMemory</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">allocation</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">uptr</span> <span class="DataType_IDENT DataType">use</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="OnStackAllocatorHeader">OnStackAllocatorHeader</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">OnStackAllocatorHeader</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">*</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="DynamicArenaAllocator">DynamicArenaAllocator</h2>The dynamic arena allocator is an arena allocator that can grow by adding additional arena &quot;pages&quot;.It only supports reset, at which point all pages except the first one is released to the backingallocator.If you want multiple save points, use the BackedArenaAllocator instead.The advantage over the BackedArenaAllocator, is that when allocating beyond the first &quot;page&quot;, it willretain the characteristics of an arena allocator (allocating a large piece of memory then handing offmemory from that memory), wheras the BackedArenaAllocator will have heap allocator characteristics.<pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">DynamicArenaAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">backing_allocator</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">DynamicArenaPage</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">DynamicArenaPage</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">unused_page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">page_size</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="Vmem">Vmem</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">Vmem</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">VirtualMemory</span> <span class="DataType_IDENT DataType">memory</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">allocated</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">pagesize</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">page_pot</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">last_page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">high_water</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">VmemOptions</span> <span class="DataType_IDENT DataType">options</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="Allocation">Allocation</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">Allocation</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_BUILTIN_TYPE DataType">void</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">ptr</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">size</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">void</span><span class="DataType_DEFAULT DataType">*</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_CONST DataType">MAX_BACKTRACE</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">backtrace</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="TrackingEnv">TrackingEnv</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">TrackingEnv</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">String</span> <span class="DataType_IDENT DataType">file</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">String</span> <span class="DataType_IDENT DataType">function</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">uint</span> <span class="DataType_IDENT DataType">line</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="BackedArenaAllocator">BackedArenaAllocator</h2>The backed arena allocator provides an allocator that will allocate from a pre-allocated chunk of memoryprovided by it&apos;s backing allocator. The allocator supports mark / reset operations, so it can be usedas a stack (push-pop) allocator. If the initial memory is used up, it will fall back to regular allocations,that will be safely freed on `reset`.While this allocator is similar to the dynamic arena, it supports multiple &quot;save points&quot;, which the dynamic arenadoesn&apos;t.<pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">BackedArenaAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_TYPE DataType">Allocator</span> <span class="DataType_IDENT DataType">backing_allocator</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_TYPE DataType">ExtraPage</span><span class="DataType_DEFAULT DataType">*</span> <span class="DataType_IDENT DataType">last_page</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">used</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">capacity</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">*</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre><h2 id="ArenaAllocator">ArenaAllocator</h2><pre><code><span class="DataType_KEYWORD DataType">struct</span> <span class="DataType_TYPE DataType">ArenaAllocator</span> <span class="DataType_DEFAULT DataType">(</span><span class="DataType_TYPE DataType">Allocator</span><span class="DataType_DEFAULT DataType">)</span>
<span class="DataType_DEFAULT DataType">{</span>
	<span class="DataType_BUILTIN_TYPE DataType">char</span><span class="DataType_DEFAULT DataType">[</span><span class="DataType_DEFAULT DataType">]</span> <span class="DataType_IDENT DataType">data</span><span class="DataType_DEFAULT DataType">;</span>
	<span class="DataType_BUILTIN_TYPE DataType">usz</span> <span class="DataType_IDENT DataType">used</span><span class="DataType_DEFAULT DataType">;</span>
<span class="DataType_DEFAULT DataType">}</span></code></pre></body></html>