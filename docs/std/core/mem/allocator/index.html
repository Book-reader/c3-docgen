<!DOCTYPE html><html><head><link rel="stylesheet" href="../../../../style.css"></head><body><iframe class="sidebar" src="./sidebar.html" scrolling="no"></iframe><div class="main"><div class="module_path"><h1><a href="../../../../std/index.html">std</a>::<a href="../../../../std/core/index.html">core</a>::<a href="../../../../std/core/mem/index.html">mem</a>::<span style="font-family: 'monospace'">allocator</span></h1></div><h2>Public</h2><h2>Types</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../../std/core/mem/allocator/type.AllocInitType.html">AllocInitType</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.SimpleHeapAllocator.html">SimpleHeapAllocator</a></td><td>The SimpleHeapAllocator implements a simple heap allocator on top of an allocator function....</td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.TrackingAllocator.html">TrackingAllocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.OnStackAllocator.html">OnStackAllocator</a></td><td>The OnStackAllocator is similar to the ArenaAllocator: it allocates from a chunk of memory...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.AlignedBlock.html">AlignedBlock</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.TempAllocator.html">TempAllocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.TempAllocatorPage.html">TempAllocatorPage</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.WasmMemory.html">WasmMemory</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.VmemOptions.html">VmemOptions</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.OnStackAllocatorHeader.html">OnStackAllocatorHeader</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.DynamicArenaAllocator.html">DynamicArenaAllocator</a></td><td>The dynamic arena allocator is an arena allocator that can grow by adding additional arena &quot;pages&quot;....</td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.Vmem.html">Vmem</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.Allocation.html">Allocation</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.TrackingEnv.html">TrackingEnv</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.BackedArenaAllocator.html">BackedArenaAllocator</a></td><td>The backed arena allocator provides an allocator that will allocate from a pre-allocated chunk of memory...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/type.ArenaAllocator.html">ArenaAllocator</a></td><td></td></tr></table><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_array.html">allocator::new_array</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.release.html">allocator::release</a></td><td>Implements the Allocator interface method.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.fprint_report.html">allocator::fprint_report</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.derive_allocator.html">allocator::derive_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.realloc.html">allocator::realloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.malloc_aligned.html">allocator::malloc_aligned</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.mark.html">allocator::mark</a></td><td>&quot;Mark&quot; the current state of the arena allocator by returning the use count.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.clone_aligned.html">allocator::clone_aligned</a></td><td>Clone overaligned values. Must be released using free_aligned.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.@aligned_alloc.html">allocator::@aligned_alloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.free_aligned.html">allocator::free_aligned</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.calloc_aligned.html">allocator::calloc_aligned</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.is_aligned.html">allocator::is_aligned</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.clone_any.html">allocator::clone_any</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_backed_allocator.html">allocator::new_backed_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.total_allocation_count.html">allocator::total_allocation_count</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.pagesize.html">allocator::pagesize</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.pop_pool.html">allocator::pop_pool</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.allocation_count.html">allocator::allocation_count</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_aligned.html">allocator::new_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.allocate_block.html">allocator::allocate_block</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.free.html">allocator::free</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new.html">allocator::new</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_temp_allocator.html">allocator::new_temp_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.acquire.html">allocator::acquire</a></td><td>Implements the Allocator interface method.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_array_aligned.html">allocator::new_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_try.html">allocator::new_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.@aligned_realloc.html">allocator::@aligned_realloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.clone_slice.html">allocator::clone_slice</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.print_report.html">allocator::print_report</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_array_try.html">allocator::new_array_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.total_allocated.html">allocator::total_allocated</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.malloc_try.html">allocator::malloc_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.temp.html">allocator::temp</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.allocated.html">allocator::allocated</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alignment_for_allocation.html">allocator::alignment_for_allocation</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.calloc_try.html">allocator::calloc_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_with_padding.html">allocator::alloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.reset.html">allocator::reset</a></td><td>Reset to a previous mark.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_array.html">allocator::alloc_array</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_array_aligned.html">allocator::alloc_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.new_with_padding.html">allocator::new_with_padding</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.destroy.html">allocator::destroy</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.realloc_aligned.html">allocator::realloc_aligned</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.has_leaks.html">allocator::has_leaks</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.heap.html">allocator::heap</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.calloc.html">allocator::calloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.owns_pointer.html">allocator::owns_pointer</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.clear.html">allocator::clear</a></td><td>Reset the usage completely.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.realloc_try.html">allocator::realloc_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.@aligned_free.html">allocator::@aligned_free</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.push_pool.html">allocator::push_pool</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.init.html">allocator::init</a></td><td>Initialize a memory arena for use using the provided bytes.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_try.html">allocator::alloc_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.malloc.html">allocator::malloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_array_try.html">allocator::alloc_array_try</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.resize.html">allocator::resize</a></td><td>Implements the Allocator interface method.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.clone.html">allocator::clone</a></td><td>Clone a value.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc.html">allocator::alloc</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.alloc_aligned.html">allocator::alloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.destroy_temp_allocators.html">allocator::destroy_temp_allocators</a></td><td>Call this to destroy any memory used by the temp allocators. This will invalidate all temp memory.</td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.allocations_tlist.html">allocator::allocations_tlist</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.wrap.html">allocator::wrap</a></td><td>Given some memory, create an arena allocator on the stack for it.</td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../../std/core/mem/allocator/global.LIBC_ALLOCATOR.html">LIBC_ALLOCATOR</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.auto_create_temp.html">auto_create_temp</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.temp_allocator_default_options.html">temp_allocator_default_options</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.WASM_BLOCK_SIZE.html">WASM_BLOCK_SIZE</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.top_temp.html">top_temp</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.MAX_BACKTRACE.html">MAX_BACKTRACE</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.temp_allocator_realloc_size.html">temp_allocator_realloc_size</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.wasm_memory.html">wasm_memory</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.current_temp.html">current_temp</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.DEFAULT_SIZE_PREFIX_ALIGNMENT.html">DEFAULT_SIZE_PREFIX_ALIGNMENT</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.temp_allocator_min_size.html">temp_allocator_min_size</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.temp_allocator_reserve_size.html">temp_allocator_reserve_size</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.DEFAULT_SIZE_PREFIX.html">DEFAULT_SIZE_PREFIX</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.NULL_ALLOCATOR.html">NULL_ALLOCATOR</a></td><td></td></tr></table><h2>Private</h2><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.create_temp_allocator.html">allocator::create_temp_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.base_allocator.html">allocator::base_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/fn.create_temp_allocator_on_demand.html">allocator::create_temp_allocator_on_demand</a></td><td></td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../../std/core/mem/allocator/global.temp_base_allocator.html">temp_base_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.thread_allocator.html">thread_allocator</a></td><td></td></tr><tr><td><a href="../../../../std/core/mem/allocator/global.LAZY_TEMP.html">LAZY_TEMP</a></td><td></td></tr></table></div></body></html>