<!DOCTYPE html><html><head><link rel="stylesheet" href="../../../style.css"></head><body><div class="main"><div class="module_path"><h1><a href="../../../std/index.html" target="_parent">std</a>::<a href="../../../std/core/index.html" target="_parent">core</a>::<span style="font-family: 'monospace'">mem</span></h1></div><h2>Submodules</h2><a href="../../../std/core/mem/volatile/index.html" target="_parent">volatile</a>&nbsp<a href="../../../std/core/mem/vm/index.html" target="_parent">vm</a>&nbsp<a href="../../../std/core/mem/ref/index.html" target="_parent">ref</a>&nbsp<a href="../../../std/core/mem/rc/index.html" target="_parent">rc</a>&nbsp<a href="../../../std/core/mem/mempool/index.html" target="_parent">mempool</a>&nbsp<a href="../../../std/core/mem/allocator/index.html" target="_parent">allocator</a>&nbsp<a href="../../../std/core/mem/alignment/index.html" target="_parent">alignment</a>&nbsp<h2>Public</h2><h2>Types</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/type.AtomicOrdering.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_type.AtomicOrdering.html'">AtomicOrdering</a></td><td></td></tr></table><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/fn.@tclone_slice.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@tclone_slice.html'">mem::@tclone_slice</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.new_array.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.new_array.html'">mem::new_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.aligned_pointer.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.aligned_pointer.html'">mem::aligned_pointer</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@stack_pool.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@stack_pool.html'">mem::@stack_pool</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.clear_inline.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.clear_inline.html'">mem::clear_inline</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.realloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.realloc.html'">mem::realloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@masked_load_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@masked_load_aligned.html'">mem::@masked_load_aligned</a></td><td>Load a vector from memory according to a mask.</td></tr><tr><td><a href="../../../std/core/mem/fn.masked_store.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.masked_store.html'">mem::masked_store</a></td><td>Store parts of a vector according to the mask, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/fn.malloc_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.malloc_aligned.html'">mem::malloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.@pool_init.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@pool_init.html'">mem::@pool_init</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.tnew.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.tnew.html'">mem::tnew</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.copy_inline.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.copy_inline.html'">mem::copy_inline</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap, it...</td></tr><tr><td><a href="../../../std/core/mem/fn.equals.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.equals.html'">mem::equals</a></td><td>Test if n elements are equal in a slice, pointed to by a pointer etc.</td></tr><tr><td><a href="../../../std/core/mem/fn.free_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.free_aligned.html'">mem::free_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.set_inline.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.set_inline.html'">mem::set_inline</a></td><td>Sets all memory in a region to that of the provided byte. Never calls OS memset.</td></tr><tr><td><a href="../../../std/core/mem/fn.tmalloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.tmalloc.html'">mem::tmalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.calloc_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.calloc_aligned.html'">mem::calloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.@unaligned_store.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@unaligned_store.html'">mem::@unaligned_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.type_alloc_must_be_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.type_alloc_must_be_aligned.html'">mem::type_alloc_must_be_aligned</a></td><td>Check if an allocation must be aligned given the type.</td></tr><tr><td><a href="../../../std/core/mem/fn.__memcpy.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.__memcpy.html'">mem::__memcpy</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@report_heap_allocs_in_scope.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@report_heap_allocs_in_scope.html'">mem::@report_heap_allocs_in_scope</a></td><td>Run the tracking allocator in the scope, then...</td></tr><tr><td><a href="../../../std/core/mem/fn.move.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.move.html'">mem::move</a></td><td>Copy memory from src to dst but correctly handle the possibility of overlapping ranges.</td></tr><tr><td><a href="../../../std/core/mem/fn.trealloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.trealloc.html'">mem::trealloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@clone_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@clone_aligned.html'">mem::@clone_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.new_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.new_aligned.html'">mem::new_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.aligned_offset.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.aligned_offset.html'">mem::aligned_offset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.get_tracking_env.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.get_tracking_env.html'">mem::get_tracking_env</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.free.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.free.html'">mem::free</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.talloc_array.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.talloc_array.html'">mem::talloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.new.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.new.html'">mem::new</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.new_array_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.new_array_aligned.html'">mem::new_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.@atomic_load.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@atomic_load.html'">mem::@atomic_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.set.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.set.html'">mem::set</a></td><td>Sets all memory in a region to that of the provided byte.</td></tr><tr><td><a href="../../../std/core/mem/fn.@scoped.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@scoped.html'">mem::@scoped</a></td><td>Run with a specific allocator inside of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/fn.@clone_slice.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@clone_slice.html'">mem::@clone_slice</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@volatile_load.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@volatile_load.html'">mem::@volatile_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@assert_leak.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@assert_leak.html'">mem::@assert_leak</a></td><td>Assert on memory leak in the scope of the macro body.</td></tr><tr><td><a href="../../../std/core/mem/fn.ptr_is_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.ptr_is_aligned.html'">mem::ptr_is_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.compare_exchange_volatile.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.compare_exchange_volatile.html'">mem::compare_exchange_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.temp_array.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.temp_array.html'">mem::temp_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.alloc_with_padding.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.alloc_with_padding.html'">mem::alloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@clone.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@clone.html'">mem::@clone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.alloc_array.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.alloc_array.html'">mem::alloc_array</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.alloc_array_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.alloc_array_aligned.html'">mem::alloc_array_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.new_with_padding.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.new_with_padding.html'">mem::new_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@masked_store_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@masked_store_aligned.html'">mem::@masked_store_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.os_pagesize.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.os_pagesize.html'">mem::os_pagesize</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@scatter_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@scatter_aligned.html'">mem::@scatter_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.realloc_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.realloc_aligned.html'">mem::realloc_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.temp_pop.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.temp_pop.html'">mem::temp_pop</a></td><td>Pop the current temp allocator. A pop must always be balanced with a push.</td></tr><tr><td><a href="../../../std/core/mem/fn.talloc_with_padding.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.talloc_with_padding.html'">mem::talloc_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@volatile_store.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@volatile_store.html'">mem::@volatile_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.calloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.calloc.html'">mem::calloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.zero_volatile.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.zero_volatile.html'">mem::zero_volatile</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.clear.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.clear.html'">mem::clear</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.copy.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.copy.html'">mem::copy</a></td><td>Copy memory from src to dst efficiently, assuming the memory ranges do not overlap.</td></tr><tr><td><a href="../../../std/core/mem/fn.masked_load.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.masked_load.html'">mem::masked_load</a></td><td>Load a vector from memory according to a mask assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/fn.@pool.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@pool.html'">mem::@pool</a></td><td>Create a new temporary allocator....</td></tr><tr><td><a href="../../../std/core/mem/fn.@atomic_store.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@atomic_store.html'">mem::@atomic_store</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.temp_with_padding.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.temp_with_padding.html'">mem::temp_with_padding</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.gather.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.gather.html'">mem::gather</a></td><td>Load values from a pointer vector, assuming default alignment.</td></tr><tr><td><a href="../../../std/core/mem/fn.@unaligned_load.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@unaligned_load.html'">mem::@unaligned_load</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@stack_mem.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@stack_mem.html'">mem::@stack_mem</a></td><td>Allocate [size] bytes on the stack to use for allocation,...</td></tr><tr><td><a href="../../../std/core/mem/fn.ptr_is_page_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.ptr_is_page_aligned.html'">mem::ptr_is_page_aligned</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.talloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.talloc.html'">mem::talloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@tclone.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@tclone.html'">mem::@tclone</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.__memset.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.__memset.html'">mem::__memset</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@gather_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@gather_aligned.html'">mem::@gather_aligned</a></td><td>Load values from a pointer vector.</td></tr><tr><td><a href="../../../std/core/mem/fn.__memcmp.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.__memcmp.html'">mem::__memcmp</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.compare_exchange.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.compare_exchange.html'">mem::compare_exchange</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.scatter.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.scatter.html'">mem::scatter</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@unaligned_addr.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@unaligned_addr.html'">mem::@unaligned_addr</a></td><td>Takes the address of a possibly unaligned variable or member,...</td></tr><tr><td><a href="../../../std/core/mem/fn.tcalloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.tcalloc.html'">mem::tcalloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.malloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.malloc.html'">mem::malloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.alloc.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.alloc.html'">mem::alloc</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.alloc_aligned.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.alloc_aligned.html'">mem::alloc_aligned</a></td><td>Allocate using an aligned allocation. This is necessary for types with a default memory alignment...</td></tr><tr><td><a href="../../../std/core/mem/fn.temp_push.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.temp_push.html'">mem::temp_push</a></td><td>Push the current temp allocator. A push must always be balanced with a pop using the current state.</td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/global.__heap_base.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.__heap_base.html'">__heap_base</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.KB.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.KB.html'">KB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.MB.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.MB.html'">MB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.GB.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.GB.html'">GB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.DEFAULT_MEM_ALIGNMENT.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.DEFAULT_MEM_ALIGNMENT.html'">DEFAULT_MEM_ALIGNMENT</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.TB.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.TB.html'">TB</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/global.MAX_MEMORY_ALIGNMENT.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.MAX_MEMORY_ALIGNMENT.html'">MAX_MEMORY_ALIGNMENT</a></td><td></td></tr></table><h2>Private</h2><h2>Functions</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/fn.initialize_wasm_mem.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.initialize_wasm_mem.html'">mem::initialize_wasm_mem</a></td><td></td></tr><tr><td><a href="../../../std/core/mem/fn.@constant_is_power_of_2.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_fn.@constant_is_power_of_2.html'">mem::@constant_is_power_of_2</a></td><td></td></tr></table><h2>Globals</h2><table><tr><th>Name</th><th>Description</th></tr><tr><td><a href="../../../std/core/mem/global.wasm_allocator.html" onclick="event.preventDefault(); window.parent.document.getElementById('main-frame').src = '../../../std/core/mem/_global.wasm_allocator.html'">wasm_allocator</a></td><td></td></tr></table></div></body></html>